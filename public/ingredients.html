<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Ingredientes necesarios</title>
	<link rel="stylesheet" href="/styles.css?v=2025-09-17-1" />
</head>
<body>
	<header class="app-header">
		<div class="header-row">
			<div class="header-left">
				<img src="/logo.png" alt="Lulitas Logo" class="app-logo" />
				<h1>Ingredientes necesarios</h1>
			</div>
			<div class="header-actions">
				<button id="back-btn" class="press-btn">Volver</button>
			</div>
		</div>
	</header>

	<main class="sales-panel">
		<div class="panel-header">
			<h3 id="title">Requerimientos por pedidos</h3>
			<div class="panel-actions">
					<button id="change-range" class="press-btn">Cambiar fechas</button>
					<button id="receta-btn" class="press-btn">Receta</button>
					<button id="whatsapp-request" class="press-btn btn-gold">Solicitar compra por WhatsApp</button>
			</div>
		</div>
		<div class="panel-body">
			<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px">
				<strong id="range-label"></strong>
				<small id="count-label" style="opacity:.8"></small>
			</div>
			<div id="counts-summary" style="display:flex; gap:10px; flex-wrap:wrap; margin:6px 0 12px 0"></div>
			<div class="table-wrapper">
				<table id="ingredients-table">
					<thead>
						<tr>
							<th>Ingrediente</th>
							<th>Por unidad</th>
							<th>Se necesitan</th>
							<th>En inventario</th>
							<th>Compras sugeridas</th>
							<th>Compras reales</th>
							<th>Precio compra</th>
						</tr>
					</thead>
					<tbody id="ingredients-tbody"></tbody>
					<tfoot>
						<tr class="report-spacer-row"><td colspan="7"></td></tr>
						<tr>
							<td class="label" colspan="4">Totales</td>
							<td id="t-buy-sug-total" class="col-total"></td>
							<td id="t-buy-real-total" class="col-total"></td>
							<td id="t-buy-cost-total" class="col-total"></td>
						</tr>
					</tfoot>
				</table>
			</div>
			<div id="dessert-summary" style="margin-top:50px"></div>
			<div id="bottom-summary" style="margin-top:50px"></div>
		</div>
	</main>

	<script type="module">
	(function(){
		const qs = new URLSearchParams(location.search);
		let start = (qs.get('start') || '').slice(0,10);
		let end = (qs.get('end') || '').slice(0,10);
		let actor = (qs.get('actor') || '').toString();
		if (!actor) { try { const saved = JSON.parse(localStorage.getItem('authUser')||'null'); actor = (saved?.name||saved?.username||'').toString(); } catch {} }
		const rangeLabel = document.getElementById('range-label');
		const countLabel = document.getElementById('count-label');
		const countsSummary = document.getElementById('counts-summary');
		const tbody = document.getElementById('ingredients-tbody');
			const tBuySugTotal = document.getElementById('t-buy-sug-total');
			const tBuyRealTotal = document.getElementById('t-buy-real-total');
			const tBuyCostTotal = document.getElementById('t-buy-cost-total');
			const backBtn = document.getElementById('back-btn');
			const changeBtn = document.getElementById('change-range');
			const waBtn = document.getElementById('whatsapp-request');
			const bottomSummary = document.getElementById('bottom-summary');
			const recetaBtn = document.getElementById('receta-btn');
			const dessertSummary = document.getElementById('dessert-summary');

			// Precios de venta por unidad (se cargarán dinámicamente)
			let PRICES = { arco: 8500, melo: 9500, mara: 10500, oreo: 10500, nute: 13000 };
			let DESSERTS = []; // Will be loaded from API

		// Lightweight embed of openRangeCalendarPopover if not present (needed on this page)
		if (typeof window.openRangeCalendarPopover !== 'function') {
			window.openRangeCalendarPopover = function(onPickedRange, anchorX, anchorY, opts){
				const pop = document.createElement('div'); pop.className = 'date-popover'; pop.style.position = 'fixed'; const baseX = anchorX||window.innerWidth/2; const baseY = anchorY||window.innerHeight/2; pop.style.left = baseX+'px'; pop.style.top=(baseY+8)+'px'; pop.style.transform='translate(-50%,0)'; pop.style.zIndex='1000';
				const months = ['Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre']; let view = new Date(); view.setDate(1); let startIso=null, endIso=null;
				const header=document.createElement('div'); header.className='date-popover-header'; const prev=document.createElement('button'); prev.className='date-nav'; prev.textContent='‹'; const label=document.createElement('div'); label.className='date-label'; const next=document.createElement('button'); next.className='date-nav'; next.textContent='›'; header.append(prev,label,next);
				const grid=document.createElement('div'); grid.className='date-grid'; const weekdays=['L','M','X','J','V','S','D']; const wk=document.createElement('div'); wk.className='date-weekdays'; for (const w of weekdays){ const c=document.createElement('div'); c.textContent=w; wk.appendChild(c);} 
				function isoUTC(y,m,d){ return new Date(Date.UTC(y,m,d)).toISOString().slice(0,10); }
				function isBetween(x,a,b){ return x>=a && x<=b; }
				function render(){ label.textContent = months[view.getMonth()] + ' ' + view.getFullYear(); grid.innerHTML=''; const year=view.getFullYear(); const month=view.getMonth(); const firstDay=(new Date(Date.UTC(year,month,1)).getUTCDay()+6)%7; const daysInMonth=new Date(Date.UTC(year,month+1,0)).getUTCDate(); for (let i=0;i<firstDay;i++){ const cell=document.createElement('button'); cell.className='date-cell disabled'; cell.disabled=true; grid.appendChild(cell);} for (let d=1; d<=daysInMonth; d++){ const iso=isoUTC(year,month,d); const cell=document.createElement('button'); let cls='date-cell'; if (startIso && !endIso && iso===startIso) cls+=' range-start selected'; if (startIso && endIso){ if (iso===startIso) cls+=' range-start selected'; else if (iso===endIso) cls+=' range-end selected'; else if (isBetween(iso,startIso,endIso)) cls+=' in-range'; } cell.className=cls; cell.textContent=String(d); cell.addEventListener('click',()=>{ if(!startIso){ startIso=iso; endIso=null; render(); return; } if(!endIso){ if(iso<startIso){ endIso=startIso; startIso=iso; } else { endIso=iso; } render(); return; } startIso=iso; endIso=null; render(); }); grid.appendChild(cell);} }
				function cleanup(){ document.removeEventListener('mousedown', outside, true); document.removeEventListener('touchstart', outside, true); if(pop.parentNode) pop.parentNode.removeChild(pop);} function outside(ev){ if(!pop.contains(ev.target)) cleanup(); }
				prev.addEventListener('click',()=>{ view.setMonth(view.getMonth()-1); render(); }); next.addEventListener('click',()=>{ view.setMonth(view.getMonth()+1); render(); });
				const actions=document.createElement('div'); actions.style.display='flex'; actions.style.justifyContent='space-between'; actions.style.marginTop='8px'; const clearBtn=document.createElement('button'); clearBtn.className='date-nav'; clearBtn.textContent='Limpiar'; const genBtn=document.createElement('button'); genBtn.className='date-nav'; genBtn.textContent='Generar'; genBtn.disabled=true; clearBtn.addEventListener('click',()=>{ startIso=null; endIso=null; genBtn.disabled=true; render(); }); genBtn.addEventListener('click',()=>{ if(startIso && endIso && typeof onPickedRange==='function'){ cleanup(); onPickedRange({ start:startIso, end:endIso }); } }); actions.append(clearBtn, genBtn);
				const origRender = render; render = function(){ origRender(); genBtn.disabled = !(startIso && endIso); };
				pop.append(header, wk, grid, actions); document.body.appendChild(pop); pop.classList.add('aladdin-pop');
				document.addEventListener('mousedown', outside, true); document.addEventListener('touchstart', outside, true); render();
			};
		}

		function formatDay(iso){
			if (!iso) return '';
			const d = new Date(iso + 'T00:00:00Z');
			const months = ['Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre'];
			return `${d.getUTCDate()} ${months[d.getUTCMonth()]} ${d.getUTCFullYear()}`;
		}

		async function fetchJSON(u){ const r = await fetch(u); if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); }

		function withActor(url){
			try {
				const u = new URL(url, location.origin);
				if (actor) u.searchParams.set('actor', actor);
				return u.pathname + (u.search || '');
			} catch { return url + (url.includes('?') ? `&actor=${encodeURIComponent(actor)}` : `?actor=${encodeURIComponent(actor)}`); }
		}

		function sumCountsView(c){
			countsSummary.innerHTML = '';
			const pills = [];
			let total = 0;
			
			// Dynamic desserts from DESSERTS array
			for (const d of DESSERTS) {
				const val = Number(c[d.short_code] || 0);
				pills.push({ label: d.name, v: val });
				total += val;
			}
			
			pills.push({ label: 'Total', v: total });
			
			for (const p of pills){
				const el = document.createElement('div');
				el.style.background = 'var(--card)'; el.style.border = '1px solid var(--border)'; el.style.borderRadius = '999px'; el.style.padding = '4px 10px';
				el.textContent = `${p.label}: ${p.v}`;
				countsSummary.appendChild(el);
			}
		}

		function openCalendar(ev){
			openRangeCalendarPopover((range) => {
				if (!range || !range.start || !range.end) return;
				start = range.start; end = range.end;
				history.replaceState(null, '', `?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}${actor?`&actor=${encodeURIComponent(actor)}`:''}`);
				load();
			}, ev.clientX, ev.clientY, { preferUp: true });
		}

		async function load(){
			if (!start || !end) return;
			rangeLabel.textContent = `${formatDay(start)} — ${formatDay(end)}`;
			countLabel.textContent = 'Cargando postres…';
			
			// Load desserts from API
			try {
				DESSERTS = await fetchJSON(withActor('/api/desserts'));
				// Build PRICES map from desserts
				PRICES = {};
				for (const d of DESSERTS) {
					PRICES[d.short_code] = d.sale_price;
				}
			} catch (err) {
				console.error('Error loading desserts:', err);
				// Fallback to hardcoded if API fails
				DESSERTS = [
					{ name: 'Arco', short_code: 'arco', sale_price: 8500 },
					{ name: 'Melo', short_code: 'melo', sale_price: 9500 },
					{ name: 'Mara', short_code: 'mara', sale_price: 10500 },
					{ name: 'Oreo', short_code: 'oreo', sale_price: 10500 },
					{ name: 'Nute', short_code: 'nute', sale_price: 13000 }
				];
				PRICES = { arco: 8500, melo: 9500, mara: 10500, oreo: 10500, nute: 13000 };
			}
			
			// 1) Build counts by dessert from sales in range
			countLabel.textContent = 'Cargando vendedores…';
			const sellers = await fetchJSON(withActor('/api/sellers'));
			countLabel.textContent = `Vendedores: ${sellers.length} · Buscando días…`;
			const isoBetween = (iso, a, b) => iso >= a && iso <= b;
			async function mapLimit(items, limit, fn) {
				const out = []; let idx = 0; let running = 0; let resolveAll; const done = new Promise(r => resolveAll = r);
				function runNext(){
					if (idx >= items.length && running === 0) return resolveAll();
					while (running < limit && idx < items.length) {
						const cur = items[idx++]; running++;
						Promise.resolve(fn(cur)).then(v => { out.push(v); running--; runNext(); }).catch(() => { running--; runNext(); });
					}
				}
				runNext(); await done; return out;
			}
			const sellerDays = [];
			await mapLimit(sellers, 6, async (s) => {
				try {
					const days = await fetchJSON(withActor(`/api/days?seller_id=${encodeURIComponent(s.id)}`));
					for (const d of (days||[])) {
						const iso = String(d.day).slice(0,10);
						if (isoBetween(iso, start, end)) sellerDays.push({ seller: s, day: d });
					}
				} catch {}
			});
			countLabel.textContent = `Días: ${sellerDays.length} · Buscando ventas…`;
			
			// Initialize counts dynamically based on desserts
			const counts = {};
			for (const d of DESSERTS) {
				counts[d.short_code] = 0;
			}
			
			await mapLimit(sellerDays, 6, async ({ seller, day }) => {
				try {
					const params = new URLSearchParams({ seller_id: String(seller.id), sale_day_id: String(day.id) });
					const sales = await fetchJSON(withActor(`/api/sales?${params.toString()}`));
					for (const r of (sales || [])) {
						// Support both old format (qty_arco) and new format (items array)
						if (Array.isArray(r.items) && r.items.length > 0) {
							// New format: use items
							for (const item of r.items) {
								if (counts[item.short_code] !== undefined) {
									counts[item.short_code] += Number(item.quantity || 0) || 0;
								}
							}
						} else {
							// Old format: use qty_* columns
							for (const d of DESSERTS) {
								const qtyKey = `qty_${d.short_code}`;
								if (r[qtyKey]) {
									counts[d.short_code] += Number(r[qtyKey] || 0) || 0;
								}
							}
						}
					}
				} catch {}
			});
			sumCountsView(counts);

			// 2) Fetch recipes and extras once (batched)
			countLabel.textContent = 'Cargando recetas…';
			const all = await fetchJSON(withActor('/api/recipes?all_items=1&include_extras=1'));
			const names = Array.isArray(all?.desserts) ? all.desserts : [];
			const extras = Array.isArray(all?.extras) ? all.extras : [];
			const itemsByDessert = new Map();
			for (const n of names) itemsByDessert.set(n, []);
			for (const it of (all?.items || [])) {
				if (!itemsByDessert.has(it.dessert)) itemsByDessert.set(it.dessert, []);
				itemsByDessert.get(it.dessert).push(it);
			}
			// Build price and pack maps from recipes/extras (defined after helper fns)
			let priceMap; let packMap; let setMapsFor;

			// 3) Fetch inventory balances
			countLabel.textContent = 'Leyendo inventario…';
			const inventory = await fetchJSON(withActor('/api/inventory'));
			const invByKey = new Map();
			for (const it of (inventory||[])) invByKey.set((it.ingredient||'').toString().toLowerCase(), Number(it.saldo||0)||0);

			// 4) Preparar render dinámico con control de postres a realizar
			countLabel.textContent = 'Calculando requerimientos…';
			const normKey = (s) => (s||'').toString().trim().toLowerCase().replace(/\s+/g,' ');
			const fmt1 = (n) => (Number(n||0)||0).toFixed(1);
			function canonicalizeName(name){
				const raw = (name||'').toString().trim();
				const low = raw.toLowerCase();
				if (!raw) return raw;
				if (low.includes('nutella')) return 'Nutella';
				if (low.includes('oreo')) return 'Oreo';
				if (low.startsWith('agua')) return 'Agua';
				if (low.includes('almibar') || low.includes('almíbar')) return 'Almíbar';
				if (low.includes('bolsa') && low.includes('cuchara')) return 'Bolsa para cuchara';
				if (low.includes('contenedor') && (low.includes('8 oz') || low.includes('8oz') || low.includes('8 onz') || low.includes('8onz'))) return 'Contenedor 8 onz';
				return raw;
			}
			function displayNameFor(name){
				const low = (name||'').toString().toLowerCase();
				if (low.includes('bolsa') && low.includes('cuchara')) return 'Bolsa para cuchara';
				if (low.includes('contenedor') && (low.includes('8 oz') || low.includes('8oz'))) return 'Contenedor 8 onz';
				return name || '';
			}
			// Build price and pack maps from recipes/extras
			priceMap = new Map();
			packMap = new Map();
			setMapsFor = function(name, unit, price, pack){
				const k = normKey(canonicalizeName(name)); if (!k) return;
				if (Number(price||0) > 0) priceMap.set(k, Number(price||0));
				if (Number(pack||0) > 0) packMap.set(k, Number(pack||0));
			};
			for (const dessertName of names){
				const arr = itemsByDessert.get(dessertName) || [];
				for (const it of arr) setMapsFor(it.ingredient, it.unit, it.price, it.pack_size);
			}
			for (const ex of (extras||[])) setMapsFor(ex.ingredient, ex.unit, ex.price, ex.pack_size);


			const baseCounts = { ...counts }; // Dynamic copy of all dessert counts
			let baseTotal = 0;
			for (const d of DESSERTS) {
				baseTotal += Number(baseCounts[d.short_code] || 0);
			}
			
			// Persistencia por rango de las cantidades editadas por postre
			const storeKey = `ingredients.counts:${start}:${end}`;
			function getSavedCounts(){
				try {
					const v = localStorage.getItem(storeKey);
					if (!v) return null;
					const o = JSON.parse(v);
					if (!o) return null;
					const result = {};
					for (const d of DESSERTS) {
						result[d.short_code] = Number(o[d.short_code] || 0) || 0;
					}
					return result;
				} catch {
					return null;
				}
			}
			function saveCounts(c){ try { localStorage.setItem(storeKey, JSON.stringify(c)); } catch {} }
			function clearSaved(){ try { localStorage.removeItem(storeKey); } catch {} }
			function renderCountsEditor(currentCounts){
				countsSummary.innerHTML = '';
				const inputs = [];
				
				// Dynamic desserts editor
				for (const d of DESSERTS) {
					const el = document.createElement('div');
					el.style.background = 'var(--card)'; el.style.border = '1px solid var(--border)'; el.style.borderRadius = '999px'; el.style.padding = '4px 10px'; el.style.display='flex'; el.style.alignItems='center'; el.style.gap='8px';
					const span = document.createElement('span'); span.textContent = d.name + ':'; span.style.fontWeight='600';
					const input = document.createElement('input'); input.type='number'; input.min='0'; input.step='1'; input.style.width='90px'; input.className='input-cell'; input.value = String(Number(currentCounts[d.short_code]||0)); input.dataset.key = d.short_code;
					el.append(span, input);
					countsSummary.appendChild(el);
					inputs.push(input);
				}
				
				const resetBtn = document.createElement('button'); resetBtn.className='press-btn'; resetBtn.textContent='Cantidades originales'; resetBtn.style.marginLeft='4px';
				resetBtn.addEventListener('click', () => { clearSaved(); renderAllForCounts({ ...baseCounts }); });
				countsSummary.appendChild(resetBtn);
				function onAnyChange(){
					const next = {};
					for (const d of DESSERTS) {
						next[d.short_code] = 0;
					}
					for (const inp of inputs){ const kk = String(inp.dataset.key||''); next[kk] = Math.max(0, Math.round(Number(inp.value||0)||0)); }
					saveCounts(next);
					renderAllForCounts(next);
				}
				for (const inp of inputs){ inp.addEventListener('input', onAnyChange); inp.addEventListener('change', onAnyChange); inp.addEventListener('blur', onAnyChange); }
			}
			const savedCounts = getSavedCounts();
			const initialCounts = savedCounts ? savedCounts : { ...baseCounts };

			function renderAllForCounts(useCounts){
				// Editor inline de conteos por postre
				renderCountsEditor(useCounts);
				// Agregado por ingrediente
				const agg = new Map();
				function addRow(_dessert, ingredient, unit, perUnit, needed){
					const canon = canonicalizeName(ingredient);
					if (canon === 'Agua' || canon === 'Almíbar') return;
					const disp = displayNameFor(canon);
					const key = normKey(canon);
					if (!key) return;
					const cur = agg.get(key) || { name: disp, perUnits: new Set(), needed: 0 };
					if (perUnit != null) cur.perUnits.add(fmt1(perUnit));
					cur.needed += Number(needed||0)||0;
					agg.set(key, cur);
				}
				const mapKey = (name) => (name||'').toString().trim().toLowerCase();
				for (const name of names){
					const arr = itemsByDessert.get(name) || [];
					const k = mapKey(name);
					
					// Find matching dessert by name
					let mult = 0;
					for (const d of DESSERTS) {
						if (k.startsWith(d.short_code) || k.includes(d.short_code)) {
							mult = Number(useCounts[d.short_code] || 0);
							break;
						}
					}
					
					if (!mult) continue;
					for (const it of arr){
						const per = Number(it.qty_per_unit||0)||0;
						addRow(name, it.ingredient, it.unit, per, per * mult);
					}
				}
				let totalUnits = 0;
				for (const d of DESSERTS) {
					totalUnits += Number(useCounts[d.short_code] || 0);
				}
				for (const ex of (extras||[])){
					const per = Number(ex.qty_per_unit||0)||0;
					addRow('Extra', ex.ingredient, ex.unit, per, per * totalUnits);
				}

				// Costos por postre (dynamic)
				const perDessertCostNeeded = {};
				for (const d of DESSERTS) {
					perDessertCostNeeded[d.short_code] = 0;
				}
				
				for (const name of names){
					const arr = itemsByDessert.get(name) || [];
					const k = mapKey(name);
					
					// Find matching dessert
					let flavor = null;
					for (const d of DESSERTS) {
						if (k.startsWith(d.short_code) || k.includes(d.short_code)) {
							flavor = d.short_code;
							break;
						}
					}
					
					const mult = flavor ? useCounts[flavor] : 0;
					if (!flavor || !mult) continue;
					for (const it of arr){
						const canon = canonicalizeName(it.ingredient);
						if (canon === 'Agua' || canon === 'Almíbar') continue;
						const per = Number(it.qty_per_unit||0)||0;
						const price = Number(it.price||0)||0;
						perDessertCostNeeded[flavor] += per * mult * price;
					}
				}
				let extrasUnitCost = 0;
				for (const ex of (extras||[])){
					const canon = canonicalizeName(ex.ingredient);
					if (canon === 'Agua' || canon === 'Almíbar') continue;
					const per = Number(ex.qty_per_unit||0)||0;
					const price = Number(ex.price||0)||0;
					extrasUnitCost += per * price;
				}
				
				// Add extras cost to all desserts
				for (const d of DESSERTS) {
					perDessertCostNeeded[d.short_code] += useCounts[d.short_code] * extrasUnitCost;
				}

				// Render tabla
				const keys = Array.from(agg.keys()).sort((a,b) => a.localeCompare(b));
				tbody.innerHTML = '';
				let buySugTotal = 0; let buyRealTotal = 0; let buyCostTotal = 0; let neededCostTotal = 0;
				const rowsState = [];
				for (const key of keys){
					const v = agg.get(key);
					const inv = invByKey.has(key) ? Number(invByKey.get(key)||0)||0 : 0;
					const buy = Math.max(0, (Number(v.needed||0)||0) - inv);
					const pack = Number(packMap.get(key) || 0) || 0;
					const real = pack > 0 ? Math.ceil(buy / pack) * pack : buy;
					const price = Number(priceMap.get(key) || 0) || 0;
					const cost = real * price;
					const perUnitDisplay = (v.perUnits && v.perUnits.size === 1) ? Array.from(v.perUnits)[0] : '—';
					const tr = document.createElement('tr');
					const tdName = document.createElement('td'); tdName.style.textAlign = 'left'; tdName.textContent = v.name;
					const tdPer = document.createElement('td'); tdPer.textContent = perUnitDisplay;
					const tdNeed = document.createElement('td'); tdNeed.textContent = fmt1(v.needed);
					const tdInv = document.createElement('td'); tdInv.textContent = fmt1(inv);
					const tdBuy = document.createElement('td'); tdBuy.className = 'col-total'; tdBuy.textContent = fmt1(buy);
					const tdReal = document.createElement('td');
					const inReal = document.createElement('input'); inReal.type = 'number'; inReal.step = '0.1'; inReal.min = '0'; inReal.className = 'input-cell'; inReal.style.width = '90px'; inReal.style.textAlign = 'right'; inReal.value = String(Number(fmt1(real))); tdReal.appendChild(inReal);
					const tdCost = document.createElement('td');
					const inCost = document.createElement('input'); inCost.type = 'number'; inCost.step = '1'; inCost.min = '0'; inCost.className = 'input-cell'; inCost.style.width = '110px'; inCost.style.textAlign = 'right'; inCost.value = String(Math.round(cost)); tdCost.appendChild(inCost);
					tr.append(tdName, tdPer, tdNeed, tdInv, tdBuy, tdReal, tdCost);
					tbody.appendChild(tr);
					buySugTotal += buy;
					buyRealTotal += real;
					buyCostTotal += Number(inCost.value || 0) || 0;
					neededCostTotal += (Number(v.needed || 0) || 0) * price;
					rowsState.push({ name: v.name, realInput: inReal, pack, costInput: inCost, unitPrice: price });
				}
				function recomputeTotals(){
					let t = 0; for (const r of rowsState) t += Number(r.costInput?.value || 0) || 0;
					buyCostTotal = t;
					tBuyCostTotal.textContent = (new Intl.NumberFormat('es-CO', { style: 'currency', currency: 'COP', maximumFractionDigits: 0 })).format(buyCostTotal);
					renderBottomSummary();
				}
				function renderDessertSummary(){
					const fmtMoney = new Intl.NumberFormat('es-CO', { style: 'currency', currency: 'COP', maximumFractionDigits: 0 });
					dessertSummary.innerHTML = '';
					const wrap = document.createElement('div');
					wrap.style.display = 'grid';
					wrap.style.gridTemplateColumns = 'repeat(auto-fit, minmax(240px, 1fr))';
					wrap.style.gap = '12px';
					function card(title, data){
						const el = document.createElement('div');
						el.style.background = 'var(--card)';
						el.style.border = '1px solid var(--border)';
						el.style.borderRadius = '10px';
						el.style.padding = '10px 12px';
						const h = document.createElement('div'); h.style.fontWeight = '700'; h.style.marginBottom = '6px'; h.textContent = title;
						const vVenta = document.createElement('div'); vVenta.innerHTML = `<strong>Valor venta:</strong> ${fmtMoney.format(data.valorVenta)}`;
						const cTot = document.createElement('div'); cTot.innerHTML = `<strong>Costos totales:</strong> ${fmtMoney.format(data.costosTotales)}`;
						const util = document.createElement('div'); util.innerHTML = `<strong>Utilidad bruta:</strong> ${fmtMoney.format(data.utilidadBruta)}`;
						const pct = document.createElement('div'); pct.innerHTML = `<strong>% utilidad:</strong> ${data.porcentaje.toFixed(1)}%`;
						el.append(h, vVenta, cTot, util, pct);
						return el;
					}
					function build(flavorKey, label){
						const valorVenta = (useCounts[flavorKey]||0) * (PRICES[flavorKey]||0);
						const costosTotales = Math.round(perDessertCostNeeded[flavorKey]||0);
						const utilidadBruta = valorVenta - costosTotales;
						const porcentaje = valorVenta>0 ? (utilidadBruta / valorVenta * 100) : 0;
						return card(label, { valorVenta, costosTotales, utilidadBruta, porcentaje });
					}
					// Dynamic desserts cards
					for (const d of DESSERTS) {
						wrap.appendChild(build(d.short_code, d.name));
					}
					dessertSummary.appendChild(wrap);
				}
				function renderBottomSummary(){
					const fmtMoney = new Intl.NumberFormat('es-CO', { style: 'currency', currency: 'COP', maximumFractionDigits: 0 });
					
					// Calculate total sales value dynamically
					let valorVenta = 0;
					for (const d of DESSERTS) {
						valorVenta += (useCounts[d.short_code] || 0) * (PRICES[d.short_code] || 0);
					}
					const costosTotales = Math.round(neededCostTotal);
					const utilidadBruta = valorVenta - costosTotales;
					const utilidadDespCompras = valorVenta - Math.round(buyCostTotal);
					bottomSummary.innerHTML = '';
					const wrap = document.createElement('div');
					wrap.style.display = 'flex';
					wrap.style.flexWrap = 'wrap';
					wrap.style.gap = '10px';
					function pill(label, value){
						const el = document.createElement('div');
						el.style.background = 'var(--card)';
						el.style.border = '1px solid var(--border)';
						el.style.borderRadius = '10px';
						el.style.padding = '10px 12px';
						el.style.minWidth = '240px';
						const strong = document.createElement('div'); strong.style.fontWeight = '600'; strong.textContent = label;
						const val = document.createElement('div'); val.style.marginTop = '4px'; val.style.fontSize = '18px'; val.style.fontVariantNumeric = 'tabular-nums'; val.textContent = fmtMoney.format(value);
						el.append(strong, val);
						return el;
					}
					wrap.append(
						pill('Costos totales', costosTotales),
						pill('Valor venta', valorVenta),
						pill('Utilidad bruta', utilidadBruta),
						pill('Utilidad después de compras', utilidadDespCompras)
					);
					bottomSummary.appendChild(wrap);
				}
				function recomputeRealTotal(){
					let t = 0; for (const r of rowsState) t += Number(r.realInput?.value || 0) || 0;
					buyRealTotal = t;
					tBuyRealTotal.textContent = fmt1(buyRealTotal);
				}
				for (const r of rowsState) {
					r.costInput.addEventListener('change', recomputeTotals);
					r.costInput.addEventListener('blur', recomputeTotals);
					function onRealEdit(){
						const realV = Number(r.realInput?.value || 0) || 0;
						const unit = Number(r.unitPrice || 0) || 0;
						r.costInput.value = String(Math.round(realV * unit));
						recomputeRealTotal();
						recomputeTotals();
					}
					r.realInput.addEventListener('change', onRealEdit);
					r.realInput.addEventListener('blur', onRealEdit);
				}
				tBuySugTotal.textContent = fmt1(buySugTotal);
				recomputeRealTotal();
				recomputeTotals();
				renderDessertSummary();
				renderBottomSummary();
				countLabel.textContent = `Ingredientes: ${keys.length}`;
				waBtn.onclick = () => {
					const pop = document.createElement('div'); pop.className = 'confirm-popover'; pop.style.position = 'fixed';
					pop.style.left = (window.innerWidth/2) + 'px'; pop.style.top = '12%'; pop.style.transform = 'translate(-50%, 0)';
					const title = document.createElement('h4'); title.textContent = 'Solicitar compra por WhatsApp'; title.style.margin = '0 0 8px 0';
					const freshLines = [];
					for (const r of rowsState) {
						const realV = Number(r.realInput?.value || 0) || 0;
						if (realV > 0) {
							if (Number(r.pack || 0) > 0) {
								const pk = Math.max(1, Math.ceil(realV / Number(r.pack)));
								freshLines.push(`${r.name} ${pk} paquete${pk===1?'':'s'}`);
							} else {
								freshLines.push(`${r.name} ${fmt1(realV)} unidades`);
							}
						}
					}
					const ta = document.createElement('textarea'); ta.style.width = 'min(92vw, 540px)'; ta.style.height = '260px'; ta.value = `${freshLines.join('\n')}\n\nTotal estimado: ${new Intl.NumberFormat('es-CO',{style:'currency',currency:'COP',maximumFractionDigits:0}).format(buyCostTotal)}`;
					const actions = document.createElement('div'); actions.className = 'confirm-actions';
					const copyBtn = document.createElement('button'); copyBtn.className = 'press-btn btn-primary'; copyBtn.textContent = 'Copiar';
					const closeBtn = document.createElement('button'); closeBtn.className = 'press-btn'; closeBtn.textContent = 'Cerrar';
					actions.append(copyBtn, closeBtn);
					pop.append(title, ta, actions);
					document.body.appendChild(pop); pop.classList.add('aladdin-pop');
					copyBtn.addEventListener('click', async () => { try { ta.select(); document.execCommand('copy'); } catch {} });
					closeBtn.addEventListener('click', () => { if (pop.parentNode) pop.parentNode.removeChild(pop); });
				};
			}

			// Render inicial con valores guardados o base
			renderAllForCounts(initialCounts);


		}

			// Back to report or home
		backBtn.addEventListener('click', () => {
		const url = new URL('/sales-report.html', location.origin);
			if (start) url.searchParams.set('start', start);
			if (end) url.searchParams.set('end', end);
			if (actor) url.searchParams.set('actor', actor);
			location.href = url.toString();
		});
		changeBtn.addEventListener('click', openCalendar);
		recetaBtn.addEventListener('click', () => {
			const url = new URL('/receta.html', location.origin);
			if (start) url.searchParams.set('start', start);
			if (end) url.searchParams.set('end', end);
			if (actor) url.searchParams.set('actor', actor);
			location.href = url.toString();
		});



		if (!start || !end) {
			countLabel.textContent = 'Selecciona un rango de fechas';
			const cx = Math.round(window.innerWidth / 2);
			const cy = 120;
			openRangeCalendarPopover((range) => {
				if (!range || !range.start || !range.end) return;
				start = range.start; end = range.end;
				history.replaceState(null, '', `?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}${actor?`&actor=${encodeURIComponent(actor)}`:''}`);
				load();
			}, cx, cy, { preferUp: true });
		} else {
			load();
		}
	})();
	</script>
</body>
</html>


<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Receta por pasos</title>
	<link rel="stylesheet" href="/styles.css?v=2025-09-17-1" />
</head>
<body>
	<header class="app-header">
		<div class="header-row">
			<div class="header-left">
				<img src="/logo.png" alt="Lulitas Logo" class="app-logo" />
				<h1>Receta por pasos</h1>
			</div>
			<div class="header-actions">
				<button id="back-btn" class="press-btn">Volver</button>
			</div>
		</div>
	</header>

	<main class="sales-panel">
		<div class="panel-header">
			<h3 id="title">Recetas con cantidades vendidas</h3>
			<div class="panel-actions">
					<button id="change-range" class="press-btn">Cambiar fechas</button>
			</div>
		</div>
		<div class="panel-body">
			<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px">
				<strong id="range-label"></strong>
				<small id="count-label" style="opacity:.8"></small>
			</div>
			<div id="counts-summary" style="display:flex; gap:10px; flex-wrap:wrap; margin:6px 0 12px 0"></div>
			<div id="cards-wrap" style="display:flex; flex-direction:column; gap:22px; margin-top:8px"></div>
		</div>
	</main>

	<script type="module">
	(function(){
		const qs = new URLSearchParams(location.search);
		let start = (qs.get('start') || '').slice(0,10);
		let end = (qs.get('end') || '').slice(0,10);
		let actor = (qs.get('actor') || '').toString();
		if (!actor) { try { const saved = JSON.parse(localStorage.getItem('authUser')||'null'); actor = (saved?.name||saved?.username||'').toString(); } catch {} }
		const rangeLabel = document.getElementById('range-label');
		const countLabel = document.getElementById('count-label');
		const countsSummary = document.getElementById('counts-summary');
		const cardsWrap = document.getElementById('cards-wrap');
		const backBtn = document.getElementById('back-btn');
		const changeBtn = document.getElementById('change-range');
 		const sessions = [];
		let desserts = [];

		// Lightweight embed of openRangeCalendarPopover if not present
		if (typeof window.openRangeCalendarPopover !== 'function') {
			window.openRangeCalendarPopover = function(onPickedRange, anchorX, anchorY){
				const pop = document.createElement('div'); pop.className = 'date-popover'; pop.style.position = 'fixed'; const baseX = anchorX||window.innerWidth/2; const baseY = anchorY||window.innerHeight/2; pop.style.left = baseX+'px'; pop.style.top=(baseY+8)+'px'; pop.style.transform='translate(-50%,0)'; pop.style.zIndex='1000';
				const months = ['Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre']; let view = new Date(); view.setDate(1); let startIso=null, endIso=null;
				const header=document.createElement('div'); header.className='date-popover-header'; const prev=document.createElement('button'); prev.className='date-nav'; prev.textContent='‹'; const label=document.createElement('div'); label.className='date-label'; const next=document.createElement('button'); next.className='date-nav'; next.textContent='›'; header.append(prev,label,next);
				const grid=document.createElement('div'); grid.className='date-grid'; const weekdays=['L','M','X','J','V','S','D']; const wk=document.createElement('div'); wk.className='date-weekdays'; for (const w of weekdays){ const c=document.createElement('div'); c.textContent=w; wk.appendChild(c);} 
				function isoUTC(y,m,d){ return new Date(Date.UTC(y,m,d)).toISOString().slice(0,10); }
				function isBetween(x,a,b){ return x>=a && x<=b; }
				function render(){ label.textContent = months[view.getMonth()] + ' ' + view.getFullYear(); grid.innerHTML=''; const year=view.getFullYear(); const month=view.getMonth(); const firstDay=(new Date(Date.UTC(year,month,1)).getUTCDay()+6)%7; const daysInMonth=new Date(Date.UTC(year,month+1,0)).getUTCDate(); for (let i=0;i<firstDay;i++){ const cell=document.createElement('button'); cell.className='date-cell disabled'; cell.disabled=true; grid.appendChild(cell);} for (let d=1; d<=daysInMonth; d++){ const iso=isoUTC(year,month,d); const cell=document.createElement('button'); let cls='date-cell'; if (startIso && !endIso && iso===startIso) cls+=' range-start selected'; if (startIso && endIso){ if (iso===startIso) cls+=' range-start selected'; else if (iso===endIso) cls+=' range-end selected'; else if (isBetween(iso,startIso,endIso)) cls+=' in-range'; } cell.className=cls; cell.textContent=String(d); cell.addEventListener('click',()=>{ if(!startIso){ startIso=iso; endIso=null; render(); return; } if(!endIso){ if(iso<startIso){ endIso=startIso; startIso=iso; } else { endIso=iso; } render(); return; } startIso=iso; endIso=null; render(); }); grid.appendChild(cell);} }
				function cleanup(){ document.removeEventListener('mousedown', outside, true); document.removeEventListener('touchstart', outside, true); if(pop.parentNode) pop.parentNode.removeChild(pop);} function outside(ev){ if(!pop.contains(ev.target)) cleanup(); }
				prev.addEventListener('click',()=>{ view.setMonth(view.getMonth()-1); render(); }); next.addEventListener('click',()=>{ view.setMonth(view.getMonth()+1); render(); });
				const actions=document.createElement('div'); actions.style.display='flex'; actions.style.justifyContent='space-between'; actions.style.marginTop='8px'; const clearBtn=document.createElement('button'); clearBtn.className='date-nav'; clearBtn.textContent='Limpiar'; const genBtn=document.createElement('button'); genBtn.className='date-nav'; genBtn.textContent='Generar'; genBtn.disabled=true; clearBtn.addEventListener('click',()=>{ startIso=null; endIso=null; genBtn.disabled=true; render(); }); genBtn.addEventListener('click',()=>{ if(startIso && endIso && typeof onPickedRange==='function'){ cleanup(); onPickedRange({ start:startIso, end:endIso }); } }); actions.append(clearBtn, genBtn);
				const origRender = render; render = function(){ origRender(); genBtn.disabled = !(startIso && endIso); };
				pop.append(header, wk, grid, actions); document.body.appendChild(pop); pop.classList.add('aladdin-pop');
				document.addEventListener('mousedown', outside, true); document.addEventListener('touchstart', outside, true); render();
			};
		}

		function formatDay(iso){ if (!iso) return ''; const d = new Date(iso + 'T00:00:00Z'); const months=['Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre']; return `${d.getUTCDate()} ${months[d.getUTCMonth()]} ${d.getFullYear()}`; }
		async function fetchJSON(u){ const r = await fetch(u); if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); }
		function withActor(url){
			try {
				const u = new URL(url, location.origin);
				if (actor) u.searchParams.set('actor', actor);
				return u.pathname + (u.search || '');
			} catch { return url + (url.includes('?') ? `&actor=${encodeURIComponent(actor)}` : `?actor=${encodeURIComponent(actor)}`); }
		}

		function sumCountsView(c){
			countsSummary.innerHTML = '';
			const pills = [];
			
			// Add pill for each dessert dynamically
			let total = 0;
			for (const d of desserts) {
				const v = c[d.short_code] || 0;
				pills.push({ label: d.name, v });
				total += v;
			}
			pills.push({ label: 'Total', v: total });
			
			for (const p of pills){ 
				const el = document.createElement('div'); 
				el.style.background = 'var(--card)'; 
				el.style.border = '1px solid var(--border)'; 
				el.style.borderRadius = '999px'; 
				el.style.padding = '4px 10px'; 
				el.textContent = `${p.label}: ${p.v}`; 
				countsSummary.appendChild(el); 
			}
		}

		// Global container for active timer buttons (right side)
		let activeTimersContainer = null;
		let timerButtonIdCounter = 0;

		function buildTimerControls(associatedRows = [], dessertName = '', stepName = '', targetElement = null){
			const stepState = { elapsedMs: 0, isRunning: false, startedAt: null };
			const wrap = document.createElement('div'); wrap.style.display='flex'; wrap.style.alignItems='center'; wrap.style.gap='8px';
			const display = document.createElement('div'); display.style.minWidth='84px'; display.style.textAlign='center'; display.style.fontVariantNumeric='tabular-nums';
			const playBtn = document.createElement('button'); playBtn.className='press-btn'; playBtn.textContent='▶'; playBtn.title='Play';
			const pauseBtn = document.createElement('button'); pauseBtn.className='press-btn'; pauseBtn.textContent='⏸'; pauseBtn.title='Pause';
			const stopBtn = document.createElement('button'); stopBtn.className='press-btn'; stopBtn.textContent='⏹'; stopBtn.title='Stop';
			wrap.append(display, playBtn, pauseBtn, stopBtn);
			function formatMs(ms){ const total=Math.max(0,Math.floor(ms/1000)); const h=Math.floor(total/3600); const m=Math.floor((total%3600)/60); const s=total%60; const pad=n=>String(n).padStart(2,'0'); return (h>0?`${h}:`:'')+`${pad(m)}:${pad(s)}`; }
			let intervalId = null;
			let activeTimerButton = null;
			const timerId = 'timer-btn-' + (++timerButtonIdCounter);
			
			function compute(){ const base=Number(stepState.elapsedMs||0)||0; if (stepState.isRunning && stepState.startedAt) return base + (Date.now()-stepState.startedAt); return base; }
			function render(){ display.textContent = formatMs(compute()); }
			function updateRowHighlight(){
				for (const row of associatedRows){
					if (stepState.isRunning) {
						row.classList.add('timer-row-active');
					} else {
						row.classList.remove('timer-row-active');
					}
				}
			}
			function createActiveTimerButton(){
				if (!activeTimersContainer || !dessertName || !stepName) return;
				
				// Remove any existing button for this timer
				removeActiveTimerButton();
				
				// Extract first word of step name
				const firstWordOfStep = stepName.split(' ')[0];
				
				const btn = document.createElement('button');
				btn.className = 'press-btn active-timer-btn';
				btn.id = timerId;
				btn.innerHTML = `<strong>${dessertName}</strong><br><small>${firstWordOfStep}</small>`;
				btn.addEventListener('click', () => {
					if (targetElement) {
						targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
						// Add a visual highlight effect
						const originalBoxShadow = targetElement.style.boxShadow;
						targetElement.style.transition = 'box-shadow 0.3s ease';
						targetElement.style.boxShadow = '0 0 20px rgba(244, 166, 183, 0.8)';
						setTimeout(() => {
							targetElement.style.boxShadow = originalBoxShadow || '';
						}, 1500);
					}
				});
				activeTimersContainer.appendChild(btn);
				activeTimerButton = btn;
			}
			function removeActiveTimerButton(){
				if (activeTimerButton && activeTimerButton.parentNode) {
					activeTimerButton.parentNode.removeChild(activeTimerButton);
				}
				activeTimerButton = null;
			}
			function play(){ 
				if (stepState.isRunning) return; 
				stepState.isRunning = true; 
				stepState.startedAt = Date.now(); 
				clearInterval(intervalId); 
				intervalId = setInterval(render, 250); 
				updateRowHighlight();
				createActiveTimerButton();
			}
			function pause(){ 
				if (!stepState.isRunning) return; 
				stepState.elapsedMs = compute(); 
				stepState.isRunning = false; 
				stepState.startedAt = null; 
				clearInterval(intervalId); 
				intervalId = null; 
				render(); 
				updateRowHighlight();
				removeActiveTimerButton();
			}
			function stop(){ 
				stepState.elapsedMs = 0; 
				stepState.isRunning = false; 
				stepState.startedAt = null; 
				clearInterval(intervalId); 
				intervalId = null; 
				render(); 
				updateRowHighlight();
				removeActiveTimerButton();
			}
			playBtn.addEventListener('click', play); pauseBtn.addEventListener('click', pause); stopBtn.addEventListener('click', stop);
			render();
			return { element: wrap, getElapsedMs: () => compute(), reset: () => { stop(); }, addRow: (row) => { associatedRows.push(row); } };
		}

		function normalizeKey(name){ const k=(name||'').toString().trim().toLowerCase(); if (k.startsWith('arco')) return 'arco'; if (k.startsWith('melo')) return 'melo'; if (k.startsWith('mara')) return 'mara'; if (k.startsWith('oreo')) return 'oreo'; if (k.startsWith('nute')) return 'nute'; return k; }
		
		// Checkbox state management (temporary, in-memory only)
		let checkedState = {};
		function getCheckedState(){
			return checkedState;
		}
		function saveCheckedState(state){
			checkedState = state;
		}

		async function load(){
			if (!start || !end) return;
			rangeLabel.textContent = `${formatDay(start)} — ${formatDay(end)}`;
			countLabel.textContent = 'Cargando…';
			cardsWrap.innerHTML = '';
			
			// Load desserts first
			try {
				desserts = await fetchJSON('/api/desserts');
			} catch {
				desserts = [
					{ id: 1, name: 'Arco', short_code: 'arco', sale_price: 8500 },
					{ id: 2, name: 'Melo', short_code: 'melo', sale_price: 9500 },
					{ id: 3, name: 'Mara', short_code: 'mara', sale_price: 10500 },
					{ id: 4, name: 'Oreo', short_code: 'oreo', sale_price: 10500 },
					{ id: 5, name: 'Nute', short_code: 'nute', sale_price: 13000 }
				];
			}
			
			// 1) Build counts by dessert from sales in range
			const sellers = await fetchJSON(withActor('/api/sellers'));
			countLabel.textContent = `Vendedores: ${sellers.length} · Buscando días…`;
			const isoBetween = (iso, a, b) => iso >= a && iso <= b;
			async function mapLimit(items, limit, fn){ const out=[]; let idx=0; let running=0; let resolveAll; const done=new Promise(r=>resolveAll=r); function runNext(){ if(idx>=items.length && running===0) return resolveAll(); while(running<limit && idx<items.length){ const cur=items[idx++]; running++; Promise.resolve(fn(cur)).then(v=>{ out.push(v); running--; runNext(); }).catch(()=>{ running--; runNext(); }); } } runNext(); await done; return out; }
			const sellerDays = [];
			await mapLimit(sellers, 6, async (s) => {
				try {
					const days = await fetchJSON(withActor(`/api/days?seller_id=${encodeURIComponent(s.id)}`));
					for (const d of (days||[])) { const iso = String(d.day).slice(0,10); if (isoBetween(iso, start, end)) sellerDays.push({ seller: s, day: d }); }
				} catch {}
			});
			countLabel.textContent = `Días: ${sellerDays.length} · Buscando ventas…`;
			
			// Initialize counts dynamically
			const counts = {};
			for (const d of desserts) {
				counts[d.short_code] = 0;
			}
			
			await mapLimit(sellerDays, 6, async ({ seller, day }) => {
				try {
					const params = new URLSearchParams({ seller_id: String(seller.id), sale_day_id: String(day.id) });
					const sales = await fetchJSON(withActor(`/api/sales?${params.toString()}`));
					for (const r of (sales || [])) {
						// Support both formats
						if (Array.isArray(r.items) && r.items.length > 0) {
							// New format
							for (const item of r.items) {
								const d = desserts.find(d => d.id === item.dessert_id || d.short_code === item.short_code);
								if (d) {
									counts[d.short_code] += Number(item.quantity || 0) || 0;
								}
							}
						} else {
							// Old format
							for (const d of desserts) {
								counts[d.short_code] += Number(r[`qty_${d.short_code}`] || 0) || 0;
							}
						}
					}
				} catch {}
			});
			sumCountsView(counts);

			// 2) Fetch dessert names and map them to keys
			let dessertNames = [];
			try { dessertNames = await fetchJSON(withActor('/api/recipes')); } catch { dessertNames = []; }
			const byKey = new Map();
			for (const name of (dessertNames||[])) { const k = normalizeKey(name); if (!byKey.has(k)) byKey.set(k, name); }

			// 3) Render a card per dessert with count > 0
			const fmt1 = new Intl.NumberFormat('es-CO', { minimumFractionDigits: 1, maximumFractionDigits: 1 });
			async function renderDessert(keyLabel, label){
				const qty = Number(counts[keyLabel] || 0) || 0; if (!qty) return;
				const dessertName = byKey.get(keyLabel) || label;
			let data = null; try { data = await fetchJSON(withActor(`/api/recipes?dessert=${encodeURIComponent(dessertName)}&include_extras=1`)); } catch { data = null; }
				if (!data) return;
				const card = document.createElement('div'); card.className = 'measure-card'; card.style.padding='12px'; card.style.border='1px solid rgba(0,0,0,0.15)'; card.style.borderRadius='10px'; card.style.boxShadow='0 8px 24px rgba(0,0,0,0.12)';
				const title = document.createElement('h3'); title.textContent = `${dessertName} × ${qty}`; title.style.textAlign='center'; title.style.fontSize='28px'; title.style.margin='4px 0 12px 0'; title.style.background='rgba(255, 105, 180, 0.18)'; title.style.padding='8px 6px'; title.style.borderRadius='8px'; card.appendChild(title);
			const session = { dessert: dessertName, qty, steps: [] };
			const checkedState = getCheckedState();
			for (const step of (Array.isArray(data.steps) ? data.steps : [])){
				const section = document.createElement('div'); section.className='measure-section'; section.style.margin='12px 0';
				const head = document.createElement('div'); head.style.display='flex'; head.style.alignItems='center'; head.style.justifyContent='space-between'; head.style.gap='8px';
				const sh = document.createElement('div'); sh.textContent = step.step_name || 'Paso'; sh.style.fontWeight='600'; sh.style.margin='0 0 6px 0'; sh.style.flex='1';
				const timer = buildTimerControls([], dessertName, step.step_name || 'Paso', section); head.append(sh, timer.element);
				section.appendChild(head);
				const table = document.createElement('table'); table.style.width='100%'; table.style.tableLayout='fixed';
				const tbody = document.createElement('tbody');
				const stepRows = [];
                    for (const it of (step.items || [])){
					const tr = document.createElement('tr');
					const itemKey = `${dessertName}:${step.step_name}:${it.ingredient}`.toLowerCase();
					const isChecked = !!checkedState[itemKey];
					if (isChecked) tr.classList.add('row-checked');
					
					// Checkbox column
					const tdCheck = document.createElement('td'); tdCheck.style.width='30px';
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.className = 'ingredient-checkbox';
					checkbox.checked = isChecked;
					checkbox.addEventListener('change', () => {
						const state = getCheckedState();
						if (checkbox.checked) {
							state[itemKey] = true;
							tr.classList.add('row-checked');
						} else {
							delete state[itemKey];
							tr.classList.remove('row-checked');
						}
						saveCheckedState(state);
					});
					tdCheck.appendChild(checkbox);
					
					const tdN = document.createElement('td'); tdN.textContent = it.ingredient; tdN.style.padding='8px 4px'; tdN.style.textAlign='center';
                        const per = Number(it.qty_per_unit || 0) || 0;
                        const adj = Number(it.adjustment || 0) || 0;
                        const total = (per * qty) + adj;
                        const tdQ = document.createElement('td'); tdQ.textContent = fmt1.format(total); tdQ.style.textAlign='right'; tdQ.style.padding='5px 4px';
					tr.append(tdCheck, tdN, tdQ);
					stepRows.push(tr);
					tbody.appendChild(tr);
				}
				// Associate header and rows with timer
				timer.addRow(head);
				for (const row of stepRows) {
					timer.addRow(row);
				}
				table.appendChild(tbody); section.appendChild(table); card.appendChild(section);
				session.steps.push({ name: step.step_name || 'Paso', timer });
				}
				// Extras - Hidden in this view (still needed for other functionality)
				// Uncomment below if you want to show extras again
				/*
				const extras = Array.isArray(data.extras) ? data.extras : [];
				if (extras.length){
					const section = document.createElement('div'); section.className='measure-section'; section.style.margin='12px 0';
					const sh = document.createElement('div'); sh.textContent = 'Extras'; sh.style.fontWeight='600'; sh.style.margin='0 0 6px 0'; section.appendChild(sh);
					const table = document.createElement('table'); table.style.width='100%'; table.style.tableLayout='fixed';
					const tbody = document.createElement('tbody');
					for (const ex of extras){
						const tr = document.createElement('tr');
						const itemKey = `${dessertName}:extras:${ex.ingredient}`.toLowerCase();
						const isChecked = !!checkedState[itemKey];
						if (isChecked) tr.classList.add('row-checked');
						
						// Checkbox column
						const tdCheck = document.createElement('td'); tdCheck.style.width='30px';
						const checkbox = document.createElement('input');
						checkbox.type = 'checkbox';
						checkbox.className = 'ingredient-checkbox';
						checkbox.checked = isChecked;
						checkbox.addEventListener('change', () => {
							const state = getCheckedState();
							if (checkbox.checked) {
								state[itemKey] = true;
								tr.classList.add('row-checked');
							} else {
								delete state[itemKey];
								tr.classList.remove('row-checked');
							}
							saveCheckedState(state);
						});
						tdCheck.appendChild(checkbox);
						
						const tdN = document.createElement('td'); tdN.textContent = ex.ingredient; tdN.style.padding='8px 4px'; tdN.style.textAlign='center';
						const tdQ = document.createElement('td'); tdQ.textContent = fmt1.format((Number(ex.qty_per_unit || 0) || 0) * qty); tdQ.style.textAlign='right'; tdQ.style.padding='5px 4px';
						tr.append(tdCheck, tdN, tdQ); tbody.appendChild(tr);
					}
					table.appendChild(tbody); section.appendChild(table); card.appendChild(section);
				}
				*/
				// Add ID to card for navigation
				card.id = `dessert-${keyLabel}`;
				cardsWrap.appendChild(card);
				sessions.push(session);
			}

			// Render cards dynamically for all desserts with count > 0
			const renderedDesserts = [];
			for (const d of desserts) {
				const hasQty = counts[d.short_code] > 0;
				if (hasQty) {
					renderedDesserts.push(d);
					await renderDessert(d.short_code, d.name);
				}
			}
			
			let totalDesserts = 0;
			for (const d of desserts) {
				totalDesserts += counts[d.short_code] || 0;
			}
			countLabel.textContent = `Postres: ${totalDesserts}`;
			
			// Create floating navigation buttons
			if (renderedDesserts.length > 0) {
				const navContainer = document.createElement('div');
				navContainer.className = 'dessert-nav-floating';
				navContainer.style.position = 'fixed';
				navContainer.style.left = '16px';
				navContainer.style.top = '50%';
				navContainer.style.transform = 'translateY(-50%)';
				navContainer.style.display = 'flex';
				navContainer.style.flexDirection = 'column';
				navContainer.style.gap = '8px';
				navContainer.style.zIndex = '100';
				
				const navButtons = [];
				const navButtonMap = new Map(); // Map dessert code to button
				
				for (const d of renderedDesserts) {
					const btn = document.createElement('button');
					btn.className = 'press-btn dessert-nav-btn';
					btn.textContent = d.name;
					btn.dataset.dessertCode = d.short_code;
					btn.style.minWidth = '80px';
					btn.style.fontSize = '13px';
					btn.style.padding = '8px 12px';
					btn.addEventListener('click', () => {
						// Remove active class from all buttons
						for (const navBtn of navButtons) {
							navBtn.classList.remove('active');
						}
						// Add active class to clicked button
						btn.classList.add('active');
						
						const card = document.getElementById(`dessert-${d.short_code}`);
						if (card) {
							card.scrollIntoView({ behavior: 'smooth', block: 'start' });
							// Add a visual highlight effect
							card.style.transition = 'box-shadow 0.3s ease';
							card.style.boxShadow = '0 8px 32px rgba(244, 166, 183, 0.6)';
							setTimeout(() => {
								card.style.boxShadow = '0 8px 24px rgba(0,0,0,0.12)';
							}, 1000);
						}
					});
					navButtons.push(btn);
					navButtonMap.set(d.short_code, btn);
					navContainer.appendChild(btn);
				}
				
				// Set first button as active by default
				if (navButtons.length > 0) {
					navButtons[0].classList.add('active');
				}
				
				document.body.appendChild(navContainer);
				
				// Create floating container for active timers (right side)
				activeTimersContainer = document.createElement('div');
				activeTimersContainer.className = 'active-timers-floating';
				activeTimersContainer.style.position = 'fixed';
				activeTimersContainer.style.right = '16px';
				activeTimersContainer.style.top = '50%';
				activeTimersContainer.style.transform = 'translateY(-50%)';
				activeTimersContainer.style.display = 'flex';
				activeTimersContainer.style.flexDirection = 'column';
				activeTimersContainer.style.gap = '8px';
				activeTimersContainer.style.zIndex = '100';
				document.body.appendChild(activeTimersContainer);
				
				// Setup Intersection Observer to auto-update active button based on scroll
				const observerOptions = {
					root: null,
					rootMargin: '-20% 0px -60% 0px', // Trigger when dessert is in upper 40% of viewport
					threshold: 0
				};
				
				const observerCallback = (entries) => {
					// Find the most visible entry
					let mostVisible = null;
					let maxRatio = 0;
					
					for (const entry of entries) {
						if (entry.isIntersecting && entry.intersectionRatio > maxRatio) {
							maxRatio = entry.intersectionRatio;
							mostVisible = entry;
						}
					}
					
					if (mostVisible) {
						const dessertId = mostVisible.target.id; // e.g., "dessert-arco"
						const dessertCode = dessertId.replace('dessert-', '');
						const activeBtn = navButtonMap.get(dessertCode);
						
						if (activeBtn && !activeBtn.classList.contains('active')) {
							// Remove active from all
							for (const navBtn of navButtons) {
								navBtn.classList.remove('active');
							}
							// Add to current
							activeBtn.classList.add('active');
						}
					}
				};
				
				const observer = new IntersectionObserver(observerCallback, observerOptions);
				
				// Observe all dessert cards
				for (const d of renderedDesserts) {
					const card = document.getElementById(`dessert-${d.short_code}`);
					if (card) {
						observer.observe(card);
					}
				}
			}
			// Actions: save times & view history
			const actions = document.createElement('div'); actions.className = 'confirm-actions'; actions.style.marginTop='8px';
			const saveBtn = document.createElement('button'); saveBtn.className='press-btn btn-primary'; saveBtn.textContent='Guardar tiempos';
			const historyBtn = document.createElement('button'); historyBtn.className='press-btn'; historyBtn.textContent='Ver historial';
			actions.append(saveBtn, historyBtn); cardsWrap.parentElement.appendChild(actions);
			function readHistory(){ try { return JSON.parse(localStorage.getItem('timesHistory') || '[]') || []; } catch { return []; } }
			function writeHistory(arr){ try { localStorage.setItem('timesHistory', JSON.stringify(arr)); } catch {} }
			function fmtMs(ms){ const total=Math.max(0,Math.floor(ms/1000)); const h=Math.floor(total/3600); const m=Math.floor((total%3600)/60); const s=total%60; const pad=n=>String(n).padStart(2,'0'); return (h>0?`${h}:`:'')+`${pad(m)}:${pad(s)}`; }
			saveBtn.addEventListener('click', async () => {
				try {
					let saved = 0;
					const hist = readHistory();
					for (const sess of sessions) {
						const qty = Number(sess.qty || 0) || 0;
						const steps = [];
						let total = 0;
						for (const st of (sess.steps || [])) {
							const ms = Number(st.timer?.getElapsedMs?.() || 0) || 0;
							if (ms > 0) {
								const avg = qty > 0 ? Math.round(ms / qty) : 0;
								steps.push({ name: st.name || 'Paso', elapsed_ms: ms, qty_units: qty, avg_ms_per_unit: avg });
								total += ms;
							}
						}
						if (!steps.length) continue;
						// Save to server
						await fetch('/api/times', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dessert: sess.dessert, steps, total_elapsed_ms: total, actor_name: null }) });
						// Save to local history
						hist.push({ id: new Date().toISOString(), date_iso: new Date().toISOString(), dessert: sess.dessert, qty_units: qty, total_elapsed_ms: total, steps });
						saved++;
					}
					writeHistory(hist);
					if (saved > 0) alert(`Tiempos guardados (${saved})`); else alert('No hay tiempos para guardar');
				} catch { alert('No se pudieron guardar los tiempos'); }
			});
			historyBtn.addEventListener('click', () => {
				const items = readHistory().slice(-20).reverse();
				const pop = document.createElement('div'); pop.className = 'confirm-popover'; pop.style.position='fixed'; pop.style.left=(window.innerWidth/2)+'px'; pop.style.top='12%'; pop.style.transform='translate(-50%,0)';
				const title = document.createElement('h4'); title.textContent = 'Historial de tiempos'; title.style.margin='0 0 8px 0';
				const list = document.createElement('div'); list.style.maxHeight='60vh'; list.style.overflow='auto'; list.style.minWidth='min(92vw,520px)';
				if (!items.length) { const empty=document.createElement('div'); empty.textContent='Sin registros'; list.appendChild(empty); }
				for (const it of items) {
					const row = document.createElement('div'); row.style.borderBottom='1px solid var(--border)'; row.style.padding='6px 2px';
					const when = new Date(it.date_iso || it.id || Date.now());
					row.innerHTML = `<strong>${it.dessert}</strong> · ${when.toLocaleString()} · Cant: ${it.qty_units||0} · Total: ${fmtMs(it.total_elapsed_ms||0)}`;
					list.appendChild(row);
				}
				const actions=document.createElement('div'); actions.className='confirm-actions'; const close=document.createElement('button'); close.className='press-btn'; close.textContent='Cerrar'; actions.appendChild(close);
				pop.append(title, list, actions); document.body.appendChild(pop); pop.classList.add('aladdin-pop');
				close.addEventListener('click', () => { if (pop.parentNode) pop.parentNode.removeChild(pop); });
			});
		}

		// Navigation
		backBtn.addEventListener('click', () => {
			const url = new URL('/sales-report.html', location.origin);
			if (start) url.searchParams.set('start', start);
			if (end) url.searchParams.set('end', end);
			if (actor) url.searchParams.set('actor', actor);
			location.href = url.toString();
		});
		changeBtn.addEventListener('click', (ev) => {
			openRangeCalendarPopover((range) => {
				if (!range || !range.start || !range.end) return;
				start = range.start; end = range.end;
				history.replaceState(null, '', `?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}${actor?`&actor=${encodeURIComponent(actor)}`:''}`);
				load();
			}, ev.clientX, ev.clientY);
		});

		if (!start || !end) {
			countLabel.textContent = 'Selecciona un rango de fechas';
			const cx = Math.round(window.innerWidth / 2);
			const cy = 120;
			openRangeCalendarPopover((range) => {
				if (!range || !range.start || !range.end) return;
			start = range.start; end = range.end;
			history.replaceState(null, '', `?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}${actor?`&actor=${encodeURIComponent(actor)}`:''}`);
				load();
			}, cx, cy);
		} else {
			load();
		}
	})();
	</script>
</body>
</html>


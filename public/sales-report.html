<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Reporte de Ventas</title>
	<link rel="stylesheet" href="/styles.css?v=2025-09-17-1" />
	<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
	<style>
		/* Skeleton loader */
		.skeleton-row td { padding: 8px; }
		.skeleton-box {
			height: 20px;
			background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
			background-size: 200% 100%;
			animation: skeleton-loading 1.5s ease-in-out infinite;
			border-radius: 4px;
		}
		@keyframes skeleton-loading {
			0% { background-position: 200% 0; }
			100% { background-position: -200% 0; }
		}
		
		/* Loading overlay */
		.loading-overlay {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(244, 166, 183, 0.9);
			z-index: 99999;
			display: flex !important;
			align-items: center;
			justify-content: center;
			backdrop-filter: blur(5px);
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.2s ease;
		}
		.loading-overlay.active { 
			opacity: 1 !important;
			pointer-events: auto;
		}
		.loading-content {
			text-align: center;
			max-width: 400px;
			padding: 32px;
			background: white;
			border-radius: 16px;
			box-shadow: 0 8px 32px rgba(0,0,0,0.1);
			transform: translateY(0);
			transition: transform 0.2s ease;
		}
		.loading-overlay:not(.active) .loading-content {
			transform: translateY(-20px);
		}
		.loading-spinner {
			width: 60px;
			height: 60px;
			margin: 0 auto 24px;
			border: 4px solid #f0f0f0;
			border-top-color: var(--primary);
			border-radius: 50%;
			animation: spin 0.8s linear infinite;
		}
		@keyframes spin {
			to { transform: rotate(360deg); }
		}
		.progress-bar-container {
			width: 100%;
			height: 8px;
			background: #f0f0f0;
			border-radius: 4px;
			overflow: hidden;
			margin: 16px 0;
		}
		.progress-bar {
			height: 100%;
			background: linear-gradient(90deg, var(--primary), var(--hover-primary-pink));
			border-radius: 4px;
			transition: width 0.3s ease;
			animation: progress-pulse 1.5s ease-in-out infinite;
		}
		@keyframes progress-pulse {
			0%, 100% { opacity: 1; }
			50% { opacity: 0.7; }
		}
		.loading-text {
			font-size: 16px;
			color: var(--text);
			margin: 8px 0;
			font-weight: 500;
		}
		.loading-subtext {
			font-size: 13px;
			color: var(--muted);
		}
		
		/* Button loading state */
		button.loading {
			pointer-events: none;
			opacity: 0.6;
			position: relative;
		}
		button.loading::after {
			content: '';
			position: absolute;
			width: 16px;
			height: 16px;
			top: 50%;
			left: 50%;
			margin-left: -8px;
			margin-top: -8px;
			border: 2px solid white;
			border-radius: 50%;
			border-top-color: transparent;
			animation: spin 0.6s linear infinite;
		}
	</style>
</head>
<body>
	<!-- Loading overlay -->
	<div id="loading-overlay" class="loading-overlay">
		<div class="loading-content">
			<div class="loading-spinner"></div>
			<div class="loading-text" id="loading-text">Cargando ventas...</div>
			<div class="progress-bar-container">
				<div class="progress-bar" id="progress-bar" style="width: 0%"></div>
			</div>
			<div class="loading-subtext" id="loading-subtext">Esto tomar√° solo un momento</div>
		</div>
	</div>
	<header class="app-header">
		<div class="header-row">
			<div class="header-left">
				<img src="/logo.png" alt="Lulitas Logo" class="app-logo" />
				<h1>Reporte de Ventas</h1>
			</div>
			<div class="header-actions">
				<button id="back-btn" class="press-btn">Volver</button>
			</div>
		</div>
	</header>

	<main class="sales-panel">
		<div class="panel-header">
			<h3 id="title">Consolidado</h3>
			<div class="panel-actions">
				<button id="change-range" class="press-btn">Cambiar fechas</button>
				<button id="export-excel" class="excel-btn press-btn btn-gold">‚§ì Generar Excel</button>
				<button id="ingredients-btn" class="press-btn">Ingredientes necesarios</button>
				<button id="compras-btn" class="press-btn btn-primary">Compras</button>
			</div>
		</div>
		<div class="panel-body">
			<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px">
				<strong id="range-label"></strong>
				<small id="count-label" style="opacity:.8"></small>
			</div>
			<div class="filters-row" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:6px 0 12px 0">
				<label style="display:flex; gap:6px; align-items:flex-start">
					<span style="line-height:28px;">Vendedores</span>
					<div id="seller-filter-group" class="seller-filter-group" style="display:flex; gap:8px; flex-wrap:wrap; min-width:220px; max-height:132px; overflow:auto; padding:8px; border:1px solid var(--border); border-radius:10px; background: var(--card);"></div>
				</label>
				<label style="display:flex; gap:6px; align-items:center">
					<span>Pago</span>
					<select id="pay-filter" class="input-cell" style="min-width:160px"></select>
				</label>
			</div>
			<div class="table-wrapper" id="report-wrapper">
				<table id="report-table">
					<thead>
						<tr id="report-thead-row">
							<th id="th-date" style="cursor:pointer">Fecha</th>
							<th id="th-seller" style="cursor:pointer">Vendedor</th>
							<th class="col-paid">$</th>
							<th id="th-pay" style="cursor:pointer">Pago</th>
							<th>Cliente</th>
							<!-- Dessert columns will be inserted here -->
							<th class="col-total">Total</th>
						</tr>
					</thead>
					<tbody id="report-tbody"></tbody>
				<tfoot id="report-tfoot">
					<tr class="report-spacer-row"><td id="spacer-td" colspan="11"></td></tr>
						<tr id="totals-row">
							<td></td>
							<td></td>
							<td></td>
							<td></td>
							<td class="label">Totales</td>
							<!-- Dessert totals will be inserted here -->
							<td class="col-total" id="t-grand"></td>
						</tr>
						<tr id="total-postres-row">
							<td></td>
							<td></td>
							<td></td>
							<td></td>
							<td class="label">Total postres</td>
							<!-- Empty dessert cells will be inserted here -->
							<td class="col-total" id="t-sum-all"></td>
						</tr>
					</tfoot>
				</table>
			</div>
		</div>
	</main>

	<script type="module">
	(function(){
		// OPTIMIZED: Pre-loaded desserts data (inline to avoid extra request)
		const PRELOADED_DESSERTS = [
			{ id: 1, name: 'Arco', short_code: 'arco', sale_price: 8500, is_active: true, position: 1 },
			{ id: 2, name: 'Melo', short_code: 'melo', sale_price: 9500, is_active: true, position: 2 },
			{ id: 3, name: 'Mara', short_code: 'mara', sale_price: 10500, is_active: true, position: 3 },
			{ id: 4, name: 'Oreo', short_code: 'oreo', sale_price: 10500, is_active: true, position: 4 },
			{ id: 5, name: 'Nute', short_code: 'nute', sale_price: 13000, is_active: true, position: 5 }
		];
		
		const qs = new URLSearchParams(location.search);
		
		// OPTIMIZED: Set intelligent default dates if not provided
		function getDefaultDates() {
			// Try to get last used dates from localStorage
			try {
				const cached = localStorage.getItem('lastReportDates');
				if (cached) {
					const parsed = JSON.parse(cached);
					const now = Date.now();
					const cacheAge = now - (parsed.timestamp || 0);
					// Use cached dates if less than 1 hour old
					if (cacheAge < 3600000 && parsed.start && parsed.end) {
						return { start: parsed.start, end: parsed.end };
					}
				}
			} catch {}
			
			// Default: last 3 days (faster loading)
			const today = new Date();
			const threeDaysAgo = new Date(today);
			threeDaysAgo.setDate(today.getDate() - 3);
			
			return {
				start: threeDaysAgo.toISOString().slice(0, 10),
				end: today.toISOString().slice(0, 10)
			};
		}
		
		const defaults = getDefaultDates();
		let start = (qs.get('start') || defaults.start).slice(0,10);
		let end = (qs.get('end') || defaults.end).slice(0,10);
		
		// Cache the dates for next time
		try {
			localStorage.setItem('lastReportDates', JSON.stringify({
				start, end, timestamp: Date.now()
			}));
		} catch {}
		
		// Actor can come from URL or localStorage (set by index page)
		let actor = (qs.get('actor') || '').toString();
		if (!actor) { try { const saved = JSON.parse(localStorage.getItem('authUser')||'null'); actor = (saved?.name||saved?.username||'').toString(); } catch {} }
		const rangeLabel = document.getElementById('range-label');
		const countLabel = document.getElementById('count-label');
		const tbody = document.getElementById('report-tbody');
		const tGrandEl = document.getElementById('t-grand');
		const tSumAllEl = document.getElementById('t-sum-all');
		const backBtn = document.getElementById('back-btn');
		const changeBtn = document.getElementById('change-range');
		const exportBtn = document.getElementById('export-excel');
		const ingredientsBtn = document.getElementById('ingredients-btn');
		const sellerFilter = document.getElementById('seller-filter');
		const payFilter = document.getElementById('pay-filter');
		const sellerFilterGroup = document.getElementById('seller-filter-group');
		const thDate = document.getElementById('th-date');
		const thSeller = document.getElementById('th-seller');
		const thPay = document.getElementById('th-pay');

		let dataset = [];
		let sellersList = [];
		let desserts = [];
		let sortKey = 'date'; // 'date' | 'seller' | 'pay'
		let sortDir = 'asc'; // 'asc' | 'desc'
		let isLoading = false; // Prevent concurrent loads
		
		// Loading overlay management
		const loadingOverlay = document.getElementById('loading-overlay');
		const loadingText = document.getElementById('loading-text');
		const loadingSubtext = document.getElementById('loading-subtext');
		const progressBar = document.getElementById('progress-bar');
		
		function showLoading(message = 'Cargando ventas...') {
			console.log('üìä showLoading called with message:', message);
			loadingText.textContent = message;
			loadingOverlay.classList.add('active');
			progressBar.style.width = '0%';
			console.log('Overlay classList:', loadingOverlay.className);
			
			// Simulate realistic progress
			let progress = 0;
			const progressInterval = setInterval(() => {
				progress += Math.random() * 15;
				if (progress > 90) progress = 90; // Stop at 90% until actual completion
				progressBar.style.width = `${progress}%`;
			}, 200);
			
			return () => {
				clearInterval(progressInterval);
				progressBar.style.width = '100%';
				setTimeout(() => {
					loadingOverlay.classList.remove('active');
				}, 300);
			};
		}
		
		function updateLoadingProgress(percent, text) {
			if (loadingOverlay.classList.contains('active')) {
				progressBar.style.width = `${percent}%`;
				if (text) loadingSubtext.textContent = text;
			}
		}

		function formatDay(iso){
			if (!iso) return '';
			const d = new Date(iso + 'T00:00:00Z');
			const months = ['Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre'];
			return `${d.getUTCDate()} ${months[d.getUTCMonth()]} ${d.getUTCFullYear()}`;
		}

		function payLabel(pm){
			return pm === 'efectivo' ? 'Efectivo' : pm === 'transf' ? 'Transf' : pm === 'marce' ? 'Marce' : pm === 'jorge' ? 'Jorge' : pm === 'jorgebank' ? 'JorgeBank' : pm === 'entregado' ? 'Entregado' : '-';
		}

		async function fetchJSON(u){ const r = await fetch(u); if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); }

		function withActor(url){
			try {
				const u = new URL(url, location.origin);
				if (actor) u.searchParams.set('actor', actor);
				return u.pathname + (u.search || '');
			} catch { return url + (url.includes('?') ? `&actor=${encodeURIComponent(actor)}` : `?actor=${encodeURIComponent(actor)}`); }
		}

		function renderDessertColumns() {
			const theadRow = document.getElementById('report-thead-row');
			const totalsRow = document.getElementById('totals-row');
			const totalPostresRow = document.getElementById('total-postres-row');
			const totalTh = theadRow.querySelector('th.col-total');
			
			// Remove existing dessert columns
			theadRow.querySelectorAll('th.col-qty').forEach(th => th.remove());
			totalsRow.querySelectorAll('td.col-qty').forEach(td => td.remove());
			totalPostresRow.querySelectorAll('td.col-qty').forEach(td => td.remove());
			
			// Insert new columns
			for (const d of desserts) {
				// Header
				const th = document.createElement('th');
				th.className = 'col-qty';
				th.textContent = d.name;
				theadRow.insertBefore(th, totalTh);
				
				// Totals row
				const tdTot = document.createElement('td');
				tdTot.className = 'col-qty';
				tdTot.id = `t-q-${d.short_code}`;
				totalsRow.insertBefore(tdTot, totalsRow.querySelector('td.col-total'));
				
				// Total postres row (empty cells)
				const tdEmpty = document.createElement('td');
				tdEmpty.className = 'col-qty';
				totalPostresRow.insertBefore(tdEmpty, totalPostresRow.querySelector('td.col-total'));
			}
			
			// Update colspan for spacer row
			const spacerTd = document.getElementById('spacer-td');
			if (spacerTd) spacerTd.colSpan = 6 + desserts.length;
		}

		function populateFilters(){
			// OPTIMIZED: Use requestIdleCallback to avoid blocking render
			requestIdleCallback(() => {
				// Sellers
				if (sellerFilterGroup) {
					const prevSelected = getSelectedSellers();
					sellerFilterGroup.innerHTML = '';
					// Master checkbox
					const masterWrap = document.createElement('label'); masterWrap.style.display='inline-flex'; masterWrap.style.alignItems='center'; masterWrap.style.gap='6px';
					const master = document.createElement('input'); master.type='checkbox'; master.id='sf_all';
					const masterSpan = document.createElement('span'); masterSpan.textContent = 'Todos';
					masterWrap.appendChild(master); masterWrap.appendChild(masterSpan);
					sellerFilterGroup.appendChild(masterWrap);
					// Vendors
					for (const s of (sellersList||[])){
						const id = `sf_${(s.name||'').replace(/[^a-z0-9]+/gi,'_')}`;
						const wrap = document.createElement('label');
						wrap.style.display = 'inline-flex'; wrap.style.alignItems = 'center'; wrap.style.gap = '6px';
						const cb = document.createElement('input'); cb.type = 'checkbox'; cb.value = s.name || ''; cb.id = id;
						cb.checked = prevSelected.length ? prevSelected.includes(cb.value) : false;
						cb.addEventListener('change', () => { updateMasterCheckboxState(); render(); });
						const sp = document.createElement('span'); sp.textContent = s.name || '';
						wrap.appendChild(cb); wrap.appendChild(sp);
						sellerFilterGroup.appendChild(wrap);
					}
					function updateMasterCheckboxState(){
						const cbs = Array.from(sellerFilterGroup.querySelectorAll('input[type="checkbox"]')).filter(x => x.id !== 'sf_all');
						const checked = cbs.filter(x => x.checked).length;
						master.indeterminate = checked > 0 && checked < cbs.length;
						master.checked = checked > 0 && checked === cbs.length;
					}
					master.addEventListener('change', () => {
						const cbs = Array.from(sellerFilterGroup.querySelectorAll('input[type="checkbox"]')).filter(x => x.id !== 'sf_all');
						for (const cb of cbs) cb.checked = master.checked;
						updateMasterCheckboxState();
						render();
					});
					updateMasterCheckboxState();
				}
				// Pay methods
				payFilter.innerHTML = '';
				const optAllP = document.createElement('option'); optAllP.value = ''; optAllP.textContent = 'Todos'; payFilter.appendChild(optAllP);
				const payCodes = ['', 'efectivo', 'transf', 'marce', 'jorge', 'jorgebank', 'entregado'];
				for (const code of payCodes){ if (code==='') continue; const o=document.createElement('option'); o.value=code; o.textContent=payLabel(code); payFilter.appendChild(o); }
			}, { timeout: 100 });
		}

		function getSelectedSellers(){
			if (sellerFilterGroup) {
				return Array.from(sellerFilterGroup.querySelectorAll('input[type="checkbox"]:checked')).map(i => i.value).filter(Boolean);
			}
			return [];
		}

		function getFilteredSortedData(){
			const selSellers = getSelectedSellers();
			const selPay = (payFilter.value || '').toString();
			let rows = dataset.filter(r => {
				if (selSellers.length && !selSellers.includes(r.sellerName)) return false;
				if (selPay && (r.pay_method || '') !== selPay) return false;
				return true;
			});
			const cmp = (a,b) => {
				let va = '', vb = '';
				if (sortKey === 'date') { va = a.date; vb = b.date; }
				else if (sortKey === 'seller') { va = (a.sellerName||'').toLowerCase(); vb = (b.sellerName||'').toLowerCase(); }
				else if (sortKey === 'pay') { va = (payLabel(a.pay_method||'')||'').toLowerCase(); vb = (payLabel(b.pay_method||'')||'').toLowerCase(); }
				if (va < vb) return sortDir === 'asc' ? -1 : 1;
				if (va > vb) return sortDir === 'asc' ? 1 : -1;
				return 0;
			};
			rows.sort(cmp);
			return rows;
		}

		function render(){
			const rows = getFilteredSortedData();
			
			// Initialize totals dynamically
			const qtys = {};
			for (const d of desserts) {
				qtys[d.short_code] = 0;
			}
			let tGrand = 0;
			
			// Calculate totals first (fast)
			for (const r of rows){
				for (const d of desserts) {
					const qty = r[`q_${d.short_code}`] || 0;
					qtys[d.short_code] += qty;
				}
				tGrand += r.tot||0;
			}
			
			// Update totals dynamically
			let totalQty = 0;
			for (const d of desserts) {
				const el = document.getElementById(`t-q-${d.short_code}`);
				if (el) el.textContent = qtys[d.short_code] || '';
				totalQty += qtys[d.short_code] || 0;
			}
			
			tGrandEl.textContent = tGrand || '';
			tSumAllEl.textContent = totalQty || '';
			countLabel.textContent = `Filas: ${rows.length}`;
			
			// Render rows in batches for better performance
			tbody.innerHTML = '';
			const fragment = document.createDocumentFragment();
			const batchSize = 50;
			let currentBatch = 0;
			
			function renderBatch() {
				const start = currentBatch * batchSize;
				const end = Math.min(start + batchSize, rows.length);
				
				for (let i = start; i < end; i++) {
					const r = rows[i];
					const row = document.createElement('tr');
					let html = `
						<td>${r.date}</td>
						<td>${r.sellerName}</td>
						<td>${r.is_paid ? '‚úì' : ''}</td>
						<td>${payLabel(r.pay_method||'')}</td>
						<td>${r.client_name||''}</td>`;
					
					// Add dessert quantities dynamically
					for (const d of desserts) {
						const qty = r[`q_${d.short_code}`] || 0;
						html += `<td>${qty || ''}</td>`;
					}
					
					html += `<td class="col-total">${r.tot||''}</td>`;
					row.innerHTML = html;
					fragment.appendChild(row);
				}
				
				tbody.appendChild(fragment);
				currentBatch++;
				
				// Schedule next batch
				if (end < rows.length) {
					requestAnimationFrame(renderBatch);
				}
			}
			
			// Start rendering
			if (rows.length > 0) {
				renderBatch();
			}
		}

		async function loadDesserts() {
			// OPTIMIZED: Use preloaded data immediately, then update in background
			// Return preloaded data instantly
			const preloaded = PRELOADED_DESSERTS.slice();
			
			// Try cache first (non-blocking)
			Promise.resolve().then(async () => {
				try {
					const cached = localStorage.getItem('dessertsCache');
					if (cached) {
						const parsed = JSON.parse(cached);
						const cacheAge = Date.now() - (parsed.timestamp || 0);
						// Use cache if less than 1 hour old
						if (cacheAge < 3600000 && parsed.data && parsed.data.length > 0) {
							desserts = parsed.data;
							renderDessertColumns();
							return;
						}
					}
				} catch {}
				
				// Load from API in background
				try {
					const data = await fetchJSON('/api/desserts');
					if (data && data.length > 0) {
						// Cache for next time
						try {
							localStorage.setItem('dessertsCache', JSON.stringify({
								data, timestamp: Date.now()
							}));
						} catch {}
						
						// Update if different from preloaded
						if (JSON.stringify(data) !== JSON.stringify(preloaded)) {
							desserts = data;
							renderDessertColumns();
							// Re-render if we already have data
							if (dataset.length > 0) {
								render();
							}
						}
					}
				} catch {}
			});
			
			return preloaded;
		}

		async function load(){
			if (!start || !end) return;
			
			// Prevent concurrent loads
			if (isLoading) return;
			isLoading = true;
			
			// Show loading overlay
			const hideLoading = showLoading('Cargando ventas...');
			
			try {
				rangeLabel.textContent = `${formatDay(start)} ‚Äî ${formatDay(end)}`;
				countLabel.textContent = '‚è≥ Cargando...';
				dataset = [];
				
				// Skeleton loader: Show animated loading rows
				const skeletonRows = 5;
				let skeletonHTML = '';
				for (let i = 0; i < skeletonRows; i++) {
					skeletonHTML += '<tr class="skeleton-row">';
					for (let j = 0; j < 8; j++) {
						skeletonHTML += '<td><div class="skeleton-box"></div></td>';
					}
					skeletonHTML += '</tr>';
				}
				tbody.innerHTML = skeletonHTML;
				
				updateLoadingProgress(20, 'Cargando postres...');
				
				// Load desserts (with cache)
				desserts = await loadDesserts();
				renderDessertColumns();
				
				updateLoadingProgress(40, 'Obteniendo ventas...');
			
			// Check if we have cached data for this exact date range
			const cacheKey = `salesCache_${start}_${end}`;
			let usedCache = false;
			
			try {
				const cached = localStorage.getItem(cacheKey);
				if (cached) {
					const parsed = JSON.parse(cached);
					const cacheAge = Date.now() - (parsed.timestamp || 0);
					// Use cache if less than 5 minutes old (for instant display)
					if (cacheAge < 300000 && parsed.sellers && parsed.sales) {
						sellersList = parsed.sellers;
						populateFilters();
						
						// Process cached sales data immediately
						countLabel.textContent = `Procesando ${parsed.sales.length} ventas‚Ä¶`;
						const dessertMap = {};
						for (const d of desserts) {
							dessertMap[d.id] = d.short_code;
							dessertMap[d.short_code] = d.short_code;
						}
						
                        dataset = parsed.sales.map(r => {
							const row = {
								date: String(r.sale_day || '').slice(0,10),
								sellerName: r.seller_name || '',
								is_paid: !!r.is_paid,
								pay_method: r.pay_method || '',
								client_name: r.client_name || '',
                                tot: Number(r.total_cents || 0) || 0
							};
							
							for (const d of desserts) {
								let qty = 0;
								if (Array.isArray(r.items) && r.items.length > 0) {
									const item = r.items.find(i => i.short_code === d.short_code);
                                    qty = item ? (Number(item.quantity || 0) || 0) : 0;
								} else {
                                    qty = Number(r[`qty_${d.short_code}`] || 0) || 0;
								}
								row[`q_${d.short_code}`] = qty;
							}
							return row;
						});
						
						render();
						usedCache = true;
						
						// Refresh in background (don't await)
						Promise.all([
							fetchJSON(withActor('/api/sellers')).catch(() => []),
							fetchJSON(withActor(`/api/sales?date_range_start=${encodeURIComponent(start)}&date_range_end=${encodeURIComponent(end)}`)).catch(() => [])
						]).then(([freshSellers, freshSales]) => {
							// Update cache
							try {
								localStorage.setItem(cacheKey, JSON.stringify({
									sellers: freshSellers,
									sales: freshSales,
									timestamp: Date.now()
								}));
							} catch {}
							
							// Only re-render if data changed
							if (JSON.stringify(freshSales) !== JSON.stringify(parsed.sales)) {
								sellersList = freshSellers;
								populateFilters();
								
								// Process fresh data
								const dessertMap = {};
								for (const d of desserts) {
									dessertMap[d.id] = d.short_code;
									dessertMap[d.short_code] = d.short_code;
								}
								
                                dataset = freshSales.map(r => {
									const row = {
										date: String(r.sale_day || '').slice(0,10),
										sellerName: r.seller_name || '',
										is_paid: !!r.is_paid,
										pay_method: r.pay_method || '',
										client_name: r.client_name || '',
                                        tot: Number(r.total_cents || 0) || 0
									};
									
									for (const d of desserts) {
										let qty = 0;
										if (Array.isArray(r.items) && r.items.length > 0) {
											const item = r.items.find(i => i.short_code === d.short_code);
                                            qty = item ? (Number(item.quantity || 0) || 0) : 0;
										} else {
                                            qty = Number(r[`qty_${d.short_code}`] || 0) || 0;
										}
										row[`q_${d.short_code}`] = qty;
									}
									return row;
								});
								
								render();
							}
						});
						
						hideLoading();
						isLoading = false;
						return; // Skip fresh fetch below
					}
				}
			} catch {}
			
			updateLoadingProgress(60, 'Consultando base de datos...');
			
			// No cache or expired - fetch fresh data
			const [sellersData, salesData] = await Promise.all([
				fetchJSON(withActor('/api/sellers')).catch(() => []),
				fetchJSON(withActor(`/api/sales?date_range_start=${encodeURIComponent(start)}&date_range_end=${encodeURIComponent(end)}`)).catch(() => [])
			]);
			
			// Cache the fresh data
			try {
				localStorage.setItem(cacheKey, JSON.stringify({
					sellers: sellersData,
					sales: salesData,
					timestamp: Date.now()
				}));
			} catch {}
			
			updateLoadingProgress(80, 'Procesando datos...');
			
			sellersList = sellersData;
			populateFilters();
			
			// Process sales data - optimized for speed
			countLabel.textContent = `Procesando ${salesData.length} ventas‚Ä¶`;
			updateLoadingProgress(90, 'Renderizando tabla...');
			
			// Pre-create lookup map for desserts
			const dessertMap = {};
			for (const d of desserts) {
				dessertMap[d.id] = d.short_code;
				dessertMap[d.short_code] = d.short_code;
			}
			
			// Process all sales in one pass
            dataset = salesData.map(r => {
				const row = {
					date: String(r.sale_day || '').slice(0,10),
					sellerName: r.seller_name || '',
					is_paid: !!r.is_paid,
					pay_method: r.pay_method || '',
					client_name: r.client_name || '',
                    tot: Number(r.total_cents || 0) || 0
				};
				
				// Process dessert quantities dynamically
				for (const d of desserts) {
					let qty = 0;
					if (Array.isArray(r.items) && r.items.length > 0) {
						// New format: use items (optimized lookup)
                        const item = r.items.find(i => i.short_code === d.short_code);
                        qty = item ? (Number(item.quantity || 0) || 0) : 0;
					} else {
						// Old format: use qty_* columns
                        qty = Number(r[`qty_${d.short_code}`] || 0) || 0;
					}
					row[`q_${d.short_code}`] = qty;
				}
				
				return row;
			});
				
				updateLoadingProgress(95, 'Finalizando...');
				render();
			} catch (error) {
				console.error('Error loading data:', error);
				countLabel.textContent = 'Error al cargar datos';
			} finally {
				hideLoading();
				isLoading = false;
			}
		}

		function openCalendar(ev){
			// Prevent multiple clicks
			if (isLoading) return;
			
			// Add visual feedback to button
			const btn = ev.currentTarget;
			btn.classList.add('loading');
			
			openRangeCalendarPopover((range) => {
				btn.classList.remove('loading');
				
				if (!range || !range.start || !range.end) return;
				
				// Check if dates actually changed
				if (range.start === start && range.end === end) {
					return; // No change, no need to reload
				}
				
				start = range.start; end = range.end;
				history.replaceState(null, '', `?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}${actor?`&actor=${encodeURIComponent(actor)}`:''}`);
				
				// Immediate visual feedback
				rangeLabel.textContent = `${formatDay(start)} ‚Äî ${formatDay(end)}`;
				
				load();
			}, ev.clientX, ev.clientY, { preferUp: true });
		}

		exportBtn.addEventListener('click', (ev) => {
			// Prevent export while loading
			if (isLoading) return;
			
			// Add visual feedback
			ev.currentTarget.classList.add('loading');
			setTimeout(() => {
				ev.currentTarget.classList.remove('loading');
			}, 1000);
			// Build Excel from filtered and sorted data currently visible
			const header = ['Fecha','Vendedor', '$', 'Pago', 'Cliente'];
			for (const d of desserts) {
				header.push(d.name);
			}
			header.push('Total');
			
			const rows = [header];
			const qtys = {};
			for (const d of desserts) {
				qtys[d.short_code] = 0;
			}
			let eGrand = 0;
			
			const data = getFilteredSortedData();
			for (const r of data){
				const row = [
					r.date,
					r.sellerName,
					r.is_paid ? '‚úì' : '',
					payLabel(r.pay_method||''),
					r.client_name||''
				];
				
				for (const d of desserts) {
					const qty = r[`q_${d.short_code}`] || 0;
					row.push(qty || '');
					qtys[d.short_code] += qty;
				}
				
				row.push(r.tot||'');
				rows.push(row);
				eGrand += r.tot||0;
			}
			// Empty spacer row before totals
			const colCount = 5 + desserts.length + 1; // Fecha, Vendedor, $, Pago, Cliente + desserts + Total
			rows.push(new Array(colCount).fill(''));
			
			// Totales row
			const totRow = new Array(colCount).fill('');
			totRow[4] = 'Totales';
			let idx = 5;
			for (const d of desserts) {
				totRow[idx++] = qtys[d.short_code] || '';
			}
			totRow[idx] = eGrand || '';
			rows.push(totRow);
			
			// Total postres row
			let sumAll = 0;
			for (const d of desserts) {
				sumAll += qtys[d.short_code] || 0;
			}
			const sumRow = new Array(colCount).fill('');
			sumRow[4] = 'Total postres';
			sumRow[colCount - 1] = sumAll || '';
			rows.push(sumRow);
			
			// Column widths
			const ws = XLSX.utils.aoa_to_sheet(rows);
			const colWidths = [{wch:10},{wch:18},{wch:3},{wch:10},{wch:24}];
			for (const d of desserts) {
				colWidths.push({wch:6});
			}
			colWidths.push({wch:10});
			ws['!cols'] = colWidths;
			const wb = XLSX.utils.book_new();
			XLSX.utils.book_append_sheet(wb, ws, 'Consolidado');
			XLSX.writeFile(wb, `Consolidado_${(start||'').replaceAll('-','')}_a_${(end||'').replaceAll('-','')}.xlsx`);
		});

		ingredientsBtn.addEventListener('click', (ev) => {
			if (isLoading) return;
			ev.currentTarget.classList.add('loading');
			const url = new URL('/ingredients.html', location.origin);
			if (start) url.searchParams.set('start', start);
			if (end) url.searchParams.set('end', end);
			if (actor) url.searchParams.set('actor', actor);
			location.href = url.toString();
		});
		
		const comprasBtn = document.getElementById('compras-btn');
		comprasBtn.addEventListener('click', (ev) => {
			if (isLoading) return;
			ev.currentTarget.classList.add('loading');
			const url = new URL('/compras.html', location.origin);
			if (start) url.searchParams.set('start', start);
			if (end) url.searchParams.set('end', end);
			if (actor) url.searchParams.set('actor', actor);
			location.href = url.toString();
		});

		backBtn.addEventListener('click', () => { 
			if (!isLoading) location.href = '/'; 
		});
		changeBtn.addEventListener('click', (ev) => {
			if (isLoading) {
				// Show toast or feedback
				console.log('Ya se est√° cargando...');
				return;
			}
			openCalendar(ev);
		});
		// sellerFilter removed (replaced by checkboxes)
		payFilter.addEventListener('change', () => render());
		function toggleSort(key){
			if (sortKey === key){ sortDir = (sortDir === 'asc') ? 'desc' : 'asc'; }
			else { sortKey = key; sortDir = 'asc'; }
			render();
		}
		thDate?.addEventListener('click', () => toggleSort('date'));
		thSeller?.addEventListener('click', () => toggleSort('seller'));
		thPay?.addEventListener('click', () => toggleSort('pay'));

		// Lightweight embed of openRangeCalendarPopover if not present
		if (typeof window.openRangeCalendarPopover !== 'function') {
			window.openRangeCalendarPopover = function(onPickedRange, anchorX, anchorY, opts){
				const pop = document.createElement('div'); 
				pop.className = 'date-popover'; 
				pop.style.position = 'fixed'; 
				pop.style.zIndex = '1000';
				
				// Build popover content first to measure it
				const months = ['Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre']; 
				let view = new Date(); 
				view.setDate(1); 
				let startIso=null, endIso=null;
				
				const header=document.createElement('div'); 
				header.className='date-popover-header'; 
				const prev=document.createElement('button'); 
				prev.className='date-nav'; 
				prev.textContent='‚Äπ'; 
				const label=document.createElement('div'); 
				label.className='date-label'; 
				const next=document.createElement('button'); 
				next.className='date-nav'; 
				next.textContent='‚Ä∫'; 
				header.append(prev,label,next);
				
				const grid=document.createElement('div'); 
				grid.className='date-grid'; 
				const weekdays=['L','M','X','J','V','S','D']; 
				const wk=document.createElement('div'); 
				wk.className='date-weekdays'; 
				for (const w of weekdays){ 
					const c=document.createElement('div'); 
					c.textContent=w; 
					wk.appendChild(c);
				}
				
				function isoUTC(y,m,d){ return new Date(Date.UTC(y,m,d)).toISOString().slice(0,10); }
				function isBetween(x,a,b){ return x>=a && x<=b; }
				function render(){ 
					label.textContent = months[view.getMonth()] + ' ' + view.getFullYear(); 
					grid.innerHTML=''; 
					const year=view.getFullYear(); 
					const month=view.getMonth(); 
					const firstDay=(new Date(Date.UTC(year,month,1)).getUTCDay()+6)%7; 
					const daysInMonth=new Date(Date.UTC(year,month+1,0)).getUTCDate(); 
					for (let i=0;i<firstDay;i++){ 
						const cell=document.createElement('button'); 
						cell.className='date-cell disabled'; 
						cell.disabled=true; 
						grid.appendChild(cell);
					} 
					for (let d=1; d<=daysInMonth; d++){ 
						const iso=isoUTC(year,month,d); 
						const cell=document.createElement('button'); 
						let cls='date-cell'; 
						if (startIso && !endIso && iso===startIso) cls+=' range-start selected'; 
						if (startIso && endIso){ 
							if (iso===startIso) cls+=' range-start selected'; 
							else if (iso===endIso) cls+=' range-end selected'; 
							else if (isBetween(iso,startIso,endIso)) cls+=' in-range'; 
						} 
						cell.className=cls; 
						cell.textContent=String(d); 
						cell.addEventListener('click',()=>{ 
							if(!startIso){ 
								startIso=iso; 
								endIso=null; 
								render(); 
								return; 
							} 
							if(!endIso){ 
								if(iso<startIso){ 
									endIso=startIso; 
									startIso=iso; 
								} else { 
									endIso=iso; 
								} 
								render(); 
								return; 
							} 
							startIso=iso; 
							endIso=null; 
							render(); 
						}); 
						grid.appendChild(cell);
					} 
				}
				
				function cleanup(){ 
					document.removeEventListener('mousedown', outside, true); 
					document.removeEventListener('touchstart', outside, true); 
					if(pop.parentNode) pop.parentNode.removeChild(pop);
				} 
				function outside(ev){ 
					if(!pop.contains(ev.target)) cleanup(); 
				}
				
				prev.addEventListener('click',()=>{ view.setMonth(view.getMonth()-1); render(); }); 
				next.addEventListener('click',()=>{ view.setMonth(view.getMonth()+1); render(); });
				
				const actions=document.createElement('div'); 
				actions.style.display='flex'; 
				actions.style.justifyContent='space-between'; 
				actions.style.marginTop='8px'; 
				const clearBtn=document.createElement('button'); 
				clearBtn.className='date-nav'; 
				clearBtn.textContent='Limpiar'; 
				const genBtn=document.createElement('button'); 
				genBtn.className='date-nav'; 
				genBtn.textContent='Generar'; 
				genBtn.disabled=true; 
				clearBtn.addEventListener('click',()=>{ 
					startIso=null; 
					endIso=null; 
					genBtn.disabled=true; 
					render(); 
				}); 
				genBtn.addEventListener('click',()=>{ 
					if(startIso && endIso && typeof onPickedRange==='function'){ 
						cleanup(); 
						onPickedRange({ start:startIso, end:endIso }); 
					} 
				}); 
				actions.append(clearBtn, genBtn);
				
				const origRender = render; 
				render = function(){ 
					origRender(); 
					genBtn.disabled = !(startIso && endIso); 
				};
				
				pop.append(header, wk, grid, actions); 
				document.body.appendChild(pop); 
				pop.classList.add('aladdin-pop');
				
				// Position popover in center of viewport after appending to measure dimensions
				requestAnimationFrame(() => {
					const popRect = pop.getBoundingClientRect();
					const viewportWidth = window.innerWidth;
					const viewportHeight = window.innerHeight;
					
					// Calculate center position
					let left = (viewportWidth - popRect.width) / 2;
					let top = (viewportHeight - popRect.height) / 2;
					
					// Ensure popover stays within viewport bounds with padding
					const padding = 16;
					if (left < padding) left = padding;
					if (top < padding) top = padding;
					if (left + popRect.width > viewportWidth - padding) {
						left = viewportWidth - popRect.width - padding;
					}
					if (top + popRect.height > viewportHeight - padding) {
						top = viewportHeight - popRect.height - padding;
					}
					
					pop.style.left = left + 'px';
					pop.style.top = top + 'px';
					pop.style.transform = 'none';
				});
				
				document.addEventListener('mousedown', outside, true); 
				document.addEventListener('touchstart', outside, true); 
				render();
			};
		}

		load();
	})();
	</script>
</body>
</html>

